# ContextAgent：开发与实施计划（修订版）

本文档概述了 `ContextAgent` 的开发需求和实施策略，这是一个为 Gemini CLI 设计的动态上下文感知系统。**此修订版整合了高级功能和详细的迭代式集成计划。**

## 1. 愿景与目标

`ContextAgent` 的主要目标是让 Gemini CLI 能够深入理解用户的项目结构、代码关系和开发上下文。这将使模型能够提供更准确、相关和智能的响应，从而有效地将 CLI 转变为一个具备项目感知能力的编码助手。

**核心目标：**

-   **自动化项目理解：** 自动分析软件项目，构建其组件的知识图谱。
-   **实时感知：** 通过监控文件变更，保持项目知识的实时更新。
-   **智能动态提示增强：** 基于分层和优先级策略，智能地将最相关的上下文注入到用户提示和模型交互中。
-   **用户友好的设置与稳健性：** 确保整个系统能够以最少的用户操作进行初始化和管理，具备良好的性能和错误处理能力，并且不依赖像 Docker 这样的复杂依赖项。

---

## 2. 核心功能与高级特性

### 2.1. 系统组件

（同前版本）

### 2.2. 功能需求

（基本需求同前版本，重点增强**动态上下文注入**）

-   **动态上下文注入 (增强版):**
    -   **上下文分层模型**: 采用四层上下文模型（L0-L3）来构造提示，确保在有限的Token预算内提供最精准的信息。
    -   **优先级与预算控制**: 实现一个动态的Token预算管理器，根据优先级（L0 > L1 > L2 > L3）贪心填充上下文，并在需要时进行智能截断。

### 2.3. 图数据库与高级模式

-   **技术选型**: （同前版本）
-   **高级模式 (Schema):** 在原有基础上，扩展更丰富的关系类型，以提供更深层次的分析能力。
    -   **基础关系**: `IMPORTS`, `CALLS`, `CONTAINS`.
    -   **扩展关系**:
        -   `IMPLEMENTS`: 连接一个类到它实现的接口。
        -   `INSTANTIATES`: 标记一个类在哪里被实例化。
        -   `REFERENCES`: 标记一个函数或变量在哪里被引用（非调用）。

### 2.4. 稳健性与性能（新增）

-   **性能优化**:
    -   **文件风暴处理**: 对文件监视器采用“防抖”(Debouncing)机制，将短时间内的大量文件变更合并为一次更新操作。
    -   **大规模图存储**: 对大型项目，考虑将图谱分片存储（例如按目录），以优化加载性能。
-   **用户体验与错误处理**:
    -   **进度反馈**: 在执行长耗时任务（如 `/init`）时，向用户提供实时进度反馈。
    -   **容错性**: 静态分析时，能够跳过语法错误的文件并记录日志，而不是中断整个流程。
    -   **智能忽略**: 首次初始化时，根据项目类型（JS, Python等）智能推荐 `.scanignore` 的内容。

### 2.5. 未来方向（新增）

-   **语义查询**: 从关键字匹配升级为基于向量嵌入的语义搜索，以理解更模糊的用户查询。
-   **可插拔分析器**: 设计一个允许添加多语言支持（如 Python, Java）的分析器架构，例如使用 `tree-sitter`。
-   **版本控制集成**: 关联 `git` 历史，以回答 “谁最后修改了此函数？” 等问题。

---

## 3. 实施与集成计划：迭代式方法

为了确保系统稳定，我们将采用一个分阶段、接口优先的迭代式集成计划。每个里程碑都构建在前一个的基础上，并保持系统随时可用。

### 里程碑 1: “空操作”集成 (接口先行)

* **目标**: 验证 `ContextAgent` 的接口已正确嵌入 CLI，但无实际功能。
1.  **接口定义**: 在 `ContextAgent` 类中创建核心方法的空实现，如 `initialize()`, `getContextForPrompt()` (返回空字符串), `processFileChange()`。
2.  **CLI 集成**: 在 Gemini CLI 的主流程中调用这些空方法。例如，执行 `/init` 时调用 `initialize()`，在准备用户 prompt 前调用 `getContextForPrompt()`。
3.  **测试**: 确认调用这些方法不会使 CLI 崩溃，并且一切照常运行。
* **产出**: 一个功能上无变化，但已为 `ContextAgent` 预留好所有接口的 CLI 版本。

### 里程碑 2: 基础静态分析与存储

* **目标**: 实现项目的首次扫描和知识图谱的本地存储。
1.  **文件扫描**: 实现一个能够读取 `.gitignore` 和 `.scanignore` 规则的文件扫描器。
2.  **基础静态分析**: 使用 AST 解析器，实现对文件、函数/类定义以及 `IMPORTS` 关系的基础分析。
3.  **图谱存储**: 集成 `graphology`，将分析结果构建为图对象，并实现将其序列化到 `context_graph.json` 的功能。
4.  **功能激活**: 填充 `initialize()` 方法的逻辑，使其在 `/init` 时执行完整的扫描和存储。
* **产出**: `/init` 命令现在可以为项目生成一个基础的知识图谱文件。上下文注入仍未激活。

### 里程碑 3: 最简上下文注入 (L3 全局概要)

* **目标**: 实现最简单的端到端上下文注入，验证流程。
1.  **摘要生成**: 实现调用 Gemini 模型生成项目高级摘要并保存到 `gemini.md` 的功能。
2.  **L3 上下文注入**: 修改 `getContextForPrompt()` 方法，使其仅读取 `gemini.md` 的内容并返回。
* **产出**: 用户现在可以从 `ContextAgent` 获得最基础的（全局的）上下文信息。

### 里程碑 4: 智能分层上下文注入

* **目标**: 实现 `ContextAgent` 的核心智能——分层上下文和预算控制。
1.  **深度分析**: 增强静态分析器，以提取 `CALLS` 等更丰富的关系。
2.  **上下文分层逻辑**: 实现 L0-L3 的上下文分层模型。开发一个函数，根据用户输入确定 L0 核心目标。
3.  **Token 预算管理器**: 实现基于优先级的贪心填充和智能截断逻辑。
4.  **功能激活**: 完全重构 `getContextForPrompt()` 方法，使其实现完整的智能上下文注入策略。
* **产出**: `ContextAgent` 现在能够根据用户输入动态提供精准、多层次的上下文。

### 里程碑 5: 实时增量更新

* **目标**: 使上下文能够自我维护，实时响应代码变更。
1.  **文件监视器**: 集成 `chokidar` 或类似库，并配置好“防抖”机制。
2.  **增量更新逻辑**: 实现 `processFileChange()` 方法，使其能够对变更的文件进行重新分析，并精确更新（添加/删除）图中的节点和边。
* **产出**: 一个能够自动保持知识图谱与项目文件同步的 `ContextAgent`。

### 里程碑 6: 稳健性与用户体验优化

* **目标**: 对系统进行打磨，使其达到生产可用标准。
1.  **实现进度反馈** 和 **错误处理** 机制 (参考 2.4 节)。
2.  **性能调优**: 对大型项目进行测试，并根据需要实现图谱分片等优化。
3.  **完善 `.scanignore` 智能推荐**。
* **产出**: 一个健壮、高效且用户友好的 `ContextAgent`。 