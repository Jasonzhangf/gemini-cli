# ContextAgent 深入分析

`ContextAgent` 是 Gemini CLI 的一个核心组件，其设计目标是构建一个动态的、上下文感知的系统。它通过静态分析项目代码，构建知识图谱，并结合用户当前的输入，为大语言模型动态提供最相关的上下文信息，从而极大地提升模型响应的准确性和相关性。

## 一、核心架构 (Architecture)

`ContextAgent` 采用模块化的组合架构，由多个各司其职的组件构成，协同完成上下文的收集、分析、存储和注入。

-   **`ContextAgent` (主控制器)**
    -   作为顶层协调者，负责初始化和管理其他所有组件的生命周期。
    -   对外提供接口，用于触发上下文注入流程。

-   **`FileScanner` (文件扫描器)**
    -   **职责**: 负责在项目目录中根据预设规则（如文件类型、忽略列表）扫描和发现相关的源文件。
    -   **工作模式**: 遵循 `.gitignore` 和自定义的忽略规则，高效地识别出需要被分析的文件列表。

-   **`StaticAnalyzer` (静态分析器)**
    -   **职责**: 对 `FileScanner` 提供的文件列表进行静态代码分析。它会解析代码（可能通过AST），提取出代码中的关键实体（如类、函数、变量、接口等）作为“节点”，以及它们之间的关系（如调用、继承、实现等）作为“边”。
    -   **产出**: 分析结果是结构化的节点和关系数据。

-   **`KnowledgeGraph` (知识图谱)**
    -   **职责**: 项目代码的“长期记忆”模块。它负责存储和管理由 `StaticAnalyzer` 生成的所有节点和关系，形成一个完整的项目代码结构图。
    -   **特性**: 支持数据的持久化存储，使得一次完整的项目扫描分析后，可以在后续的会话中快速加载和查询，无需重复分析。

-   **`LayeredContextManager` (分层上下文管理器)**
    -   **职责**: 这是 `ContextAgent` 的“大脑”和核心决策单元。它在接收到用户输入后，智能地从 `KnowledgeGraph` 中查询信息，并结合其他策略，生成一个分层的、有主次之分的上下文。
    -   **分层策略**: 从代码中可以看到，它可能会生成多个“层”的上下文，例如：
        -   **直接相关层**: 根据用户输入中的关键词，直接从知识图谱中找到最相关的代码片段。
        -   **结构洞察层**: 提供高维度的项目结构信息。
        -   **意图分析层**: 分析用户输入的潜在意图。
        -   **近期变更层**: 关注最近被修改过的文件，因为它们很可能与当前任务相关。
    -   **输出**: 最终生成一个为模型优化过的、高度相关的文本上下文。

## 二、设计机制与触发条件 (Mechanism & Triggers)

`ContextAgent` 的工作流程主要由两个核心机制驱动：**初始化**和**运行时上下文注入**。

### 1. 初始化流程 (Initialization)

这是 `ContextAgent` 的冷启动过程，目标是对整个项目进行一次全面的“摸底排查”，构建起完整的知识图谱。

-   **触发条件**:
    -   在 `ContextAgent` 实例创建后，首次需要注入上下文之前被自动调用。
    -   也可以通过 `reinitialize()` 方法手动触发，用于强制重新扫描整个项目。

-   **执行步骤**:
    1.  **启动**: `initialize()` 方法被调用。
    2.  **扫描**: `FileScanner` 扫描整个项目，找出所有符合条件的源文件。
    3.  **分析**: `StaticAnalyzer` 遍历扫描到的文件，解析并提取出所有的代码节点和关系。
    4.  **构建**: `KnowledgeGraph` 接收分析结果，将这些节点和关系存入图数据库中。
    5.  **持久化**: `KnowledgeGraph` 将构建好的图谱保存到磁盘，以便未来快速加载。
    6.  **完成**: `ContextAgent` 标记为已初始化，准备好进入运行时状态。

### 2. 运行时上下文注入 (Runtime Context Injection)

这是 `ContextAgent` 最核心的日常工作，它在用户每次与CLI交互时被触发，为模型提供“即时”的上下文。

-   **触发条件**:
    -   在用户的输入（Prompt）即将被发送给 Gemini 大模型之前，`injectContextIntoDynamicSystem()` 方法会被调用。

-   **执行步骤**:
    1.  **接收输入**: `injectContextIntoDynamicSystem()` 接收到用户的原始输入。
    2.  **获取上下文**: 该方法会立即调用 `getContextForPrompt()` 来生成上下文。
    3.  **智能查询**: 在 `getContextForPrompt()` 内部，`LayeredContextManager` 开始工作。它会分析用户输入，并根据分层策略从 `KnowledgeGraph` 中查询最相关的信息。
    4.  **格式化**: `LayeredContextManager` 将所有查询到的、不同层次的上下文信息，整合成一个单一、干净、易于模型理解的文本字符串。
    5.  **注入**: `ContextAgent` 获取到格式化后的上下文文本，并将其注入到最终发送给模型的 Prompt 中。代码中的 `FORCE ENABLE` 注释表明，即使生成上下文失败，也会注入一个最小化的提示信息，确保其存在。

### 3. 文件变更处理 (File Change Handling)

为了保持知识图谱的实时性，`ContextAgent` 还具备处理文件变更的能力。

-   **触发条件**:
    -   当文件系统中的代码文件被创建、修改或删除时，`processFileChange()` 方法可以被调用。

-   **执行步骤**:
    1.  接收到变更文件的路径和变更类型。
    2.  `ContextAgent` 会针对性地重新分析这个文件。
    3.  `KnowledgeGraph` 会相应地更新（增加、修改或删除）图谱中的节点和关系，而无需重新扫描整个项目，从而实现了高效的增量更新。 